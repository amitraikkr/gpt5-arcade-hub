<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Minesweeper</title>
    <style>
        :root {
            --cell-size: 34px;
            --bg: #1f2937;
            --panel: #111827;
            --accent: #10b981;
            --danger: #ef4444;
            --text: #e5e7eb;
            --muted: #9ca3af;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 
                         "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
            background: linear-gradient(180deg, #0b1020, #0e1224 40%, #12172b);
            color: var(--text);
            display: grid;
            place-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .wrap {
            width: min(95vw, 720px);
        }

        .topbar {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .title {
            font-weight: 700;
            letter-spacing: .5px;
            color: #c7d2fe;
        }

        .controls {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            align-items: center;
        }

        .controls input {
            width: 64px;
            background: #0b1020;
            border: 1px solid #334155;
            color: var(--text);
            padding: 6px 8px;
            border-radius: 6px;
            text-align: center;
        }

        .btn {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #334155;
            color: var(--text);
            background: #0b1020;
            cursor: pointer;
        }

        .btn:hover {
            border-color: #4b5563;
        }

        .status {
            text-align: center;
            font-weight: 600;
            color: var(--muted);
        }

        .status.ok {
            color: var(--accent);
        }

        .status.fail {
            color: var(--danger);
        }

        .panel {
            background: #0b1020;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,.35);
        }

        .info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--muted);
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid #334155;
            background: #0b1020;
            color: var(--text);
            font-weight: 600;
        }

        .board {
            user-select: none;
            display: grid;
            gap: 6px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            display: grid;
            place-items: center;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid #334155;
            background: #0f172a;
            color: var(--text);
            transition: transform .05s;
        }

        .cell:hover {
            transform: translateY(-1px);
        }

        .cell.revealed {
            background: #0a0f1f;
            border-color: #3b4252;
            cursor: default;
        }

        .cell.flagged {
            background: #132336;
            border-color: #1f3b57;
        }

        .cell.mine.revealed {
            background: #3b0f1f;
            border-color: #7f1d1d;
        }

        .cell.exploded {
            background: #a30e2d;
            border-color: #ef4444;
            color: #fff;
        }

        .n0 { color: #93a2b1; }
        .n1 { color: #60a5fa; }
        .n2 { color: #34d399; }
        .n3 { color: #f59e0b; }
        .n4 { color: #f472b6; }
        .n5 { color: #f87171; }
        .n6 { color: #22d3ee; }
        .n7 { color: #c084fc; }
        .n8 { color: #eab308; }

        .legend {
            margin-top: 10px;
            font-size: 12px;
            color: var(--muted);
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="topbar">
            <div class="title">Minesweeper</div>
            <div class="status" id="status">Good luck!</div>
            <div class="controls">
                <input id="rows" type="number" min="5" max="30" value="10" title="Rows" />
                <input id="cols" type="number" min="5" max="30" value="10" title="Columns" />
                <input id="mines" type="number" min="5" max="200" value="15" title="Mines" />
                <button class="btn" id="resetBtn">New game</button>
            </div>
        </div>
        <div class="panel">
            <div class="info">
                <div>Mines: <span class="badge" id="mineCount">0</span></div>
                <div>Flags left: <span class="badge" id="flagsLeft">0</span></div>
            </div>
            <div id="board" class="board" aria-label="Minesweeper board"></div>
            <div class="legend">Left-click: reveal â€” Right-click: flag</div>
        </div>
    </div>

    <script>
        (() => {
            const boardEl = document.getElementById('board');
            const statusEl = document.getElementById('status');
            const mineCountEl = document.getElementById('mineCount');
            const flagsLeftEl = document.getElementById('flagsLeft');
            const rowsInput = document.getElementById('rows');
            const colsInput = document.getElementById('cols');
            const minesInput = document.getElementById('mines');
            const resetBtn = document.getElementById('resetBtn');

            let rows = 10, cols = 10, minesTotal = 15;
            let gameOver = false;
            let board = [];
            let revealedCount = 0;
            let flagsLeft = 0;

            const inBounds = (r, c) => r >= 0 && r < rows && c >= 0 && c < cols;

            const neighbors = (r, c) => {
                const res = [];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = r + dr, nc = c + dc;
                        if (inBounds(nr, nc)) res.push([nr, nc]);
                    }
                }
                return res;
            };

            function buildBoard() {
                board = Array.from({length: rows}, (_, r) =>
                    Array.from({length: cols}, (_, c) => ({
                        r, c,
                        isMine: false,
                        revealed: false,
                        flagged: false,
                        adj: 0,
                        el: null
                    }))
                );
            }

            function placeMines() {
                const total = rows * cols;
                const positions = Array.from({length: total}, (_, i) => i);

                // Shuffle using Fisher-Yates
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                for (let i = 0; i < minesTotal; i++) {
                    const idx = positions[i];
                    const r = Math.floor(idx / cols);
                    const c = idx % cols;
                    board[r][c].isMine = true;
                }
            }

            function computeAdjacency() {
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (board[r][c].isMine) {
                            board[r][c].adj = 0;
                            continue;
                        }
                        let count = 0;
                        for (const [nr, nc] of neighbors(r, c)) {
                            if (board[nr][nc].isMine) count++;
                        }
                        board[r][c].adj = count;
                    }
                }
            }

            function makeCellElement(cell) {
                const el = document.createElement('div');
                el.className = 'cell';
                el.setAttribute('role', 'button');
                el.setAttribute('aria-label', 'Hidden cell');
                el.dataset.r = cell.r;
                el.dataset.c = cell.c;
                el.addEventListener('click', onLeftClick);
                el.addEventListener('contextmenu', onRightClick);
                return el;
            }

            function drawBoard() {
                boardEl.innerHTML = '';
                boardEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = board[r][c];
                        const el = makeCellElement(cell);
                        cell.el = el;
                        boardEl.appendChild(el);
                    }
                }
            }

            function updateHUD() {
                mineCountEl.textContent = String(minesTotal);
                flagsLeftEl.textContent = String(flagsLeft);
            }

            function setStatus(text, cls = null) {
                statusEl.textContent = text;
                statusEl.className = 'status' + (cls ? ' ' + cls : '');
            }

            function revealCell(cell, explode = false) {
                if (cell.revealed) return;
                cell.revealed = true;
                revealedCount++;
                cell.el.classList.add('revealed');
                cell.el.setAttribute('aria-label', cell.isMine ? 'Mine' : `Revealed ${cell.adj}`);

                if (cell.flagged) {
                    cell.flagged = false;
                    cell.el.classList.remove('flagged');
                    flagsLeft++;
                    updateHUD();
                }

                if (cell.isMine) {
                    cell.el.classList.add('mine');
                    if (explode) cell.el.classList.add('exploded');
                    cell.el.textContent = 'ðŸ’£';
                    return;
                }

                const n = cell.adj;
                if (n > 0) {
                    cell.el.textContent = n;
                    cell.el.classList.add(`n${n}`);
                } else {
                    cell.el.classList.add('n0');
                }
            }

            function floodReveal(r, c) {
                const q = [[r, c]];
                const seen = new Set([`${r},${c}`]);

                while (q.length) {
                    const [cr, cc] = q.shift();
                    const current = board[cr][cc];
                    revealCell(current);

                    if (current.adj !== 0) continue;

                    for (const [nr, nc] of neighbors(cr, cc)) {
                        const key = `${nr},${nc}`;
                        const ncell = board[nr][nc];
                        if (!seen.has(key) && !ncell.revealed && !ncell.isMine && !ncell.flagged) {
                            seen.add(key);
                            q.push([nr, nc]);
                        }
                    }
                }
            }

            function onLeftClick(e) {
                if (gameOver) return;
                const el = e.currentTarget;
                const r = Number(el.dataset.r);
                const c = Number(el.dataset.c);
                const cell = board[r][c];

                if (cell.revealed || cell.flagged) return;

                if (cell.isMine) {
                    revealCell(cell, true);
                    revealAllMines();
                    endGame(false);
                    return;
                }

                if (cell.adj === 0) {
                    floodReveal(r, c);
                } else {
                    revealCell(cell);
                }

                checkWin();
            }

            function onRightClick(e) {
                e.preventDefault();
                if (gameOver) return;

                const el = e.currentTarget;
                const r = Number(el.dataset.r);
                const c = Number(el.dataset.c);
                const cell = board[r][c];

                if (cell.revealed) return;

                if (cell.flagged) {
                    cell.flagged = false;
                    el.classList.remove('flagged');
                    el.textContent = '';
                    flagsLeft++;
                } else if (flagsLeft > 0) {
                    cell.flagged = true;
                    el.classList.add('flagged');
                    el.textContent = 'ðŸš©';
                    flagsLeft--;
                }

                updateHUD();
            }

            function revealAllMines() {
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = board[r][c];
                        if (cell.isMine && !cell.revealed) revealCell(cell);
                    }
                }
            }

            function checkWin() {
                if (revealedCount === rows * cols - minesTotal) {
                    endGame(true);
                }
            }

            function endGame(won) {
                gameOver = true;
                if (won) {
                    setStatus('Passed', 'ok');
                } else {
                    setStatus('Failed', 'fail');
                }

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const el = board[r][c].el;
                        el.style.pointerEvents = 'none';
                    }
                }
            }

            function clampInt(v, min, max, fallback) {
                v = parseInt(v, 10);
                if (Number.isNaN(v)) return fallback;
                return Math.min(max, Math.max(min, v));
            }

            function init() {
                rows = clampInt(rowsInput.value, 5, 30, 10);
                cols = clampInt(colsInput.value, 5, 30, 10);

                // Limit mines to at most 80% of board to keep it solvable-ish
                const maxMines = Math.max(1, Math.floor(rows * cols * 0.8));
                minesTotal = clampInt(minesInput.value, 1, maxMines, Math.min(20, Math.floor(rows * cols / 5)));

                rowsInput.value = rows;
                colsInput.value = cols;
                minesInput.value = minesTotal;

                gameOver = false;
                revealedCount = 0;
                flagsLeft = minesTotal;

                setStatus('Good luck!');
                buildBoard();
                placeMines();
                computeAdjacency();
                drawBoard();
                updateHUD();
            }

            // Events
            resetBtn.addEventListener('click', init);
            rowsInput.addEventListener('change', init);
            colsInput.addEventListener('change', init);
            minesInput.addEventListener('change', init);

            // Start
            init();
        })();
    </script>
</body>
</html>
